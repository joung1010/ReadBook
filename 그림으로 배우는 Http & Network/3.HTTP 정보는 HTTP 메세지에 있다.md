## HTTP 메세지  

HTTP 에서 교환하는 정보는 HTTP 메세지라보 불리는데 리퀘스트 측 HTTP 메세지를 **리퀘스트 메세지**,  
리스폰스측 에서의 HTTP 메세지를 **리스폰스 메세지** 라고 부른다.  
HTTP 메세지는 복수 행(개행 문자는 CR+LF)의 데이터로 구성된 텍스트 문자열이다.  
HTTP 메세지를 크게 구분하면 3부분으로 구분할 수 있다.  
* 메세지 헤더 : 서버와 클라이언트가 꼭 처리해야하는 리퀘스트와 리스폰스 내용과 속성등 
* 개행문자(CR+LF) : CR(Carriage Return : 16진수 0x0d)와 LF(Line Feed : 16진수 0x0a)
* 메세지바디 : 꼭 전송되는 데이터 그 자체  

## 리퀘스트 메세지 와 리스폰스 메세지 구조  

```
 리퀘스트 메세지

메세지 헤더      ------->        리퀘스트라인
                                 리퀘스트 헤더 필드
                                 일반 헤더 필드
                                 엔티티 헤더 필드
                                 그외...
                                 
리스폰스 메세지

메세지 헤더     --------->        상태라인
                                  리스폰스 헤더 필드
                                  일반 헤더 필드
                                  엔티티 헤더 필드
                                  그외 ....
                                  
```  
* 리퀘스트 라인: 리퀘스트에 사용하는 메소드와 리퀘스트 URI 와 사용하는 HTTP 버전이 포함  
ex) GET /reader/ HTTP / 1.1  
* 상태 라인 : 리스폰스 결과를 나타내느 상태코드와 설명, HTTP 버전이 포함  
ex) HTTP / 1.1 200 OK  
* 헤더 필드 : 리퀘스트 와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함됨, 일반헤더, 리퀘스트헤더 필드, 리스폰스 헤더필드, 엔티티 헤더필드 등 4종류가 있다.  
* 그외 헤더에 쿠키 등이 포함되는 경우 도 있다.  
  
#### 인코딩으로 전송 효율을 높이다.  
HTTP로 데이터를 전송할 경우 그대로 전송할 수 있지만 전송할 때에 인코딩(변환)을 실시함으로써 전송 효율을 높일 수 있다.  
  
#### 메세지 바디와 엔티티 바디의 차이  
* 메세지 : HTTP 통신의 기본 단위로 옥텟 시퀀스(Octet sequence8비트)로 구성되고 통신을 통해서 전송된다.
* 엔티티 : 리퀘스트랑 리스폰스의 페이로드(payload 부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디 필드로 구성된다.  
HTTP 메세지 바디의 역할은 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일이다.  
기본적으로 메세지 바디와 엔티티 바디는 같지만 전송 코딩이 적용되는 경우에는 엔티티 바디의 내용이 변화하기 때문에  
메세지 바디와 달라집니다.  
  
####  압축을해서 보내는 콘텐츠 코딩  
메일에 파일을 첨부할때 용량을 줄이기 위해서 파일을 압축하는 것처럼  
HTTP는 이와 같은 일이 가능한 콘텐츠 코딩 이라는 기능이 구현되어 있다.  
콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데 엔티티 정보를 유지한채로 압축한다.  
이 콘텐츠 코딩은 수신하는 측에서 디코딩을 한다.  
콘텐츠 코딩의 종류는  
* gzip(GNU ZIP)
* compress(UNIX의 표준 압축)
* deflate(zlib)
* identity(인코딩 없음)  
  
#### 분해해서 보내는 청크 전송 코딩  

HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면  
브라이저에 표시되지 않는다. 사이즈가 큰 데이터를 전송하는경우 데이터를 조금씩 분할해서 조금씩 표시할 수 있다.  
이렇게 엔티티 바디를 분할하는 기능을 **청크 코딩**이라고 부른다.  
청크 전송 코딩은 엔티티 바디를 청크(덩어리)로 분해한다.  
다음 청크 사이즈를 16진수로 사용해서 단락을 표시하고 엔티티 바디 끝에 0(CR+LF)를 기록해둔다.  
이 청크 코딩한 바디를 수신한 쪽에서는 엔치치 바디를 디코딩한다.  

#### 여러 데이터를 보내는 멀티파트  
  
메일의경우 본문이나 복수의 첨부파일을 붙여서 함께 보낼수 있는데 이것을  
**MIME(Multipurpose Internet Mail Extensions: 다목적 인터넷 메일 확장 사양)** 이라고 부른다.  
이 MIME의 확장 사양에 있는 **멀티파트(Multipart)** 라고 하는 여러 다른 동류의 데이터를 수용하는 방법을 사용하고 있다.  
HTTP 도 멀티파트에 대응하고 있어 하나의 메세지 바디 내부에 엔티티를 여러개 포함시켜 보낼 수 있다.  
주로 **이미지나 텍스트 파일등을 업로드**할때 사용되고 있다.  

## 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션  

같은 콘텐츠(내용)이지만 여러 개의 페이지를 지닌 웹페이지가 있다.  
예를 들어 같은 URI에 엑세스하지만 한국어 페이지와 영어 페이지를 표시합니다.  
이와 같은 구조로를 **컨텐츠 네고시에이션(Content Negotiation)** 이라고 한다.  
콘텐츠 네고시에이션은 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것이다.  
클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다.  
콘텐츠 네고시에이션이 제공하는 리소스를 언어와 문자세트, 인코딩 방식등을 기준으로 판단하고 있다.  
판단기준이 되는 리퀘스트 헤더 필드는 다음과 같다.  
* Accept
* Accept-Charset
* Accept-Encoding
* Accept-Language
* Content-Language  

#### 서버 구동형 네고시에이션(Server-driven Negotiation)  

서버 측에서 콘텐츠 네고시에이션을 하는 방식, 서버측 에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리한다.  
단, 브라우저 측에서 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한것이 선택되었다고 할 수 없다.  
  
#### 에이전트 구동형 네고시에이션(Agent-Driven Negotiation)  

클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식, 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다.  
  
#### 트랜스페어런드 네고시에이션(Transparent Negotiation)  

서버 구동형과 에이전트 구동형을 혼합한 것으로 서버와 클라이언트 각각 콘텐츠 네고시에에이션을 하는 방식








